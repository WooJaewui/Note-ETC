
 # 오리엔테이션

 박문석 - 01037901997,     ggangpae1@gmail.com

 수업자료 : ggangpae1.tistory.com

 시험과목

1 - 요구사항 확인.             		         UML 1 ~ 2개 ( 어렵다 )
2 - 프로그래밍 언어.           	         3 ~ 5  ( C, Java, Python 에서 출제 ) ( 무조건 맞춰야 됨 )
				         코딩이 따로 없고, ( ) 넣기 형식으로 출제된다.  ( 읽어 내려 갈 수 있으면 됨 )

3 - SQL 응용.                   		         ( 데이터베이스 이론 1, SQL 1~2 ) ( 무조건 맞춰야 됨 )
4 - 데이터 입출력 구현.       		         EAI, ESB, 데이터 포맷 2개정도. ( 무조건 맞춰야 됨 )

5 - 통합 구현.			         과목을 나누는 의미가 없다. 
6 - 서버 프로그램 구현.		         과목을 나누는 의미가 없다. 
7 - 인터페이스 구현.		         과목을 나누는 의미가 없다. 
8 - 화면 설계.			         과목을 나누는 의미가 없다. 

9 - 소프트웨어 테스트 관리.                       1 ~ 2 개 ( 맞춰야 된다 )
10 - 소프트웨어 개발 보안 구축.	         2개 이상. ( 어렵다 )
11 - 응용 소프트웨어 기초 기술 활용.           네트워크 : 1 ~ 2 개, 신기술용어 : 1 ~ 2개  ( 어렵다 )
12 - 제품 소프트웨어 패키징. 	         형상 관리 - 1개. ( 맞춰야 된다 )

 수업 진행.

1주차 : 프로그래밍 언어, 테스트, 소프트웨어 패키징.
2주차 : 데이터베이스, 기초기술활용, 보안, 요구사항확인.

다 진행하지 못 한 부분은 따로 시간을 내서 수업을 해주심.


 # 프로그래밍 언어.

사람이 생각하는 것을 컴퓨터가 이해할 수 있도록 만드는 작업을 위한 언어.


 # 프로그래밍 언어 분류. ( 여러가지 형식을 다 가질 수 있다 )


1.절차적언어와 비절차적 언어.

절차적언어 : 코딩한 순서대로 실행되는 언어.
비절차적언어 : 코딩한 순서와 무관하게 실행되는 언어 - SQL이 대표적.

SQL ( 비절차적인 언어 )

SELECT ( 5 )
FROM ( 1 )
WHERE ( 2 )
GROUP BY ( 3 )
HAVING ( 4 )
ORDER BY ( 6 )

이런식으로 순서가 정해져 있다. ( 내가 코드한 순서와 상관없이 진행 )


2. 구조적 프로그래밍 언어.

블럭을 사용할 수 있는 언어 : 제어문이나 예외처리 및 함수, 클래스를 이용해서 블럭 단위 코딩과 실행이 가능한 언어.
                                    블럭 대신에 모듈이라고 표현하기도 함.


3. 객체 지향 프로그래밍 언어.

클래스의 개념을 가진 언어. 
C언어는 클래스 개념이 없다.
자바스크립트는 class가 없지만 object만 있는 객체기반언어이다. ( Node.js 같은 프로그램에는 있다 )


4. 스크립트 언어.

코드를 미리 번역( Compile )하지 않고 실행할 때 줄 단위로 읽어서 실행하는 언어. 
ex ) 자바스크립트, 파이썬, R, Swift( ios ), ASP.net( C#문법 ), JSP( Java ), PHP, Ruby 등.

스크립트 언어가 아닌 언어들은 한 번에 실행해야 하는 명령어 뒤에 종결 부호가 있음.
=> ' ; ' 세미콜론으로 문장을 종결 시켜줌.

스크립트 언어의 경우에는 ' ; ' 을 사용할 필요가 없지만 
한 줄에 2개 이상의 실행코드가 있는 경우 2개를 실행 할 수 없으므로 ' ; '으로 구분한다.


5. 선언형 언어.

알고리즘은 기술하지 않고 문제만 기술하는 언어.
ex ) HTML, CSS, XML, LISP, Haskell, PROLOG 등. 


6. 함수형 프로그래밍 언어.

함수가 일급 객체로 취급되는 언어이다.
함수를 하나의 자료형으로 사용할 수 있다.( 변수, 매개변수, 리턴 타입 ) 
함수 안에 함수를 생성할 수 있다.
함수만 별도로 존재 할 수 있다.
ex ) 파이썬이 대표적인 함수형 언어. ( Scala, Kotlin 등 이 JVM 기반의 대표적인 함수형 언어 ) 

Java로 함수형을 공부하려면 JDK 1.8 이후에 추가된 람다와 스트림 API를 공부할 것.
-> 안드로이드에서 메소드가 1개 뿐인 인터페이스나 추상 클래스를 anonymous class를 이용해서 구현하면
    안드로이드 스튜디오가 코드 최적화를 위해서 람다로 변경합니다.


 # compile

사람이 알아보는 코드를 기계가 알아볼 수 있도록 번역하는 작업.


 # 객체 지향 용어.

1. 클래스, 객체, Instance

클래스 : 유사한 역할을 수행하는 객체들의 모임 : 모형, 사용자 정의자료형, 모델하우스개념. ( 얘도 하나의 객체이다 )
Object : 프로그램에서 존재하는 모든 것.
Instance : 클래스를 기반으로 생성한 객체이다. ( 우리나라말로 실례, 사례 등으로 해석 ) 


2. 속성( attribute, property, field 등 )와 메소드( method ).

속성 : 클래스나 객체의 정보를 저장하기 위해서 클래스나 객체가 소유하고 있는 변수.
        클래스 안에 만들면 속성, 밖에 만들면 variable.
메소드 : 한 번에 수행해야 하는 코드의 모임에 이름을 붙여놓은 것.
          클래스나 인스턴스가 메소드를 호출하는 것을 메시지를 전송한다고 하기도 한다.
          클래스 안에 만들면 method, 밖에 만들면 function.


3. Encapsulation ( 캡슐화 )

Encapsulation : 동일한 목적을 위해서 사용되는 속성과 메소드를 묶는 작업. ( 클래스를 만드는 것 )
                   정보 은닉 ( Information Hiding ) : 불 필요한 부분을 숨기는 작업에 사용된다. 접근 지정자 사용.


4. Inheritance ( 상속 )

Inheritance : 하위 클래스가 상위 클래스의 모든 것을 물려받는 것.
                상속을 그림으로 그릴 때 하위 클래스에서 상위 클래스 방향으로 그린다.
                ( 아래부터 그리고 위로 올라오면서 그린다 )

여러 class들에 중복된 부분이 많이 있을때, 부모 class를 만들어서 중복을 효율적으로 사용할 수 있다.


5. Polymorphism ( 다형성 )

Polymorphism : 동일한 메시지에 대하여 다르게 반응하는 성질.
                    동일한 코드가 호출하는 객체에 따라 다른 메소드를 호출하는 것.
                    상속과 method overriding으로 구현한다.

method overriding : 상위 클래스의 메소드와 동일한 원형의 메소드를 하위 클래스에서 다시 정의하는 것.
                          ex ) 스마트폰에 지역화, 마우스 동작.
method overloading : 하나의 클래스의 메소드의 이름이 같고 매개변수의 개수나 자료형이 다른 경우.


 # 프로그래밍 언어.

C, Java, Python.

1. 프로그램이 실행되는 과정.
 - 소스코드 ( 프로그래밍 언어에 맞게 작성한 코드 - 인간이 알아보는 코드 ) 작성.  
 - Compile ( 프로그램을 실행할 수 있는 운영체제나 가상머신이 이해하는 코드로 번역 C -> obj, Java -> class 생성 )
                에러 발생시 : 문법이 틀린 것.
 - Build ( 만들어진 코드를 실행할 수 있는 코드로 변경 - 스타트업 코드나 로딩 순서 등을 확인 ) 
            에러 발생 : 클래스, obj가 없거나 스타트업 코드가 없거나 2개 이상인 경우이다.
 - Loading ( 프로그램을 실행할 수 있도록 Main memory에 코드를 올리는 작업 )
 - Run ( 실행 )


2. 프로그래밍을 하기 위해서 필요한 도구.
 - 컴파일러 ( 필수 ) : C언어는 Mac, Linux, Unix에 내장. ( C언어는 Unix를 만들기 위해서 등장한 언어 )
                          Unix가 상용화 되어서 만들어진 운영체제 Linux.
                          Unix에 GUI를 입힌 운영체제 : Mac OS X, IOS.
                          Linux에 GUI를 입힌 운영체제 : Android.
                          Mac OS X을 이용해서 자신들의 C언어로 코드를 입힌 운영체제 : MS Windows. 
                          Windows에서는 C Compiler를 깔아야됨.

ex ) Java -> JDK ( Compiler ) JRE ( 자바 실행 도구 ) 필수 설치, Python -> Python Compiler,   C -> C Compiler.

 - IDE ( 통합 개발 도구 - 개발의 전 과정을 할 수 있도록 도와주는 프로그램 )
   : 선택적으로 설치 - 없어도 프로그래밍을 못하는 것이 아니고 불편하다. 


     C : Mac에서는 X-Code를 가지고 할 수 있음.
     Windows에서는 Visual C++ ( Python - Visual Studio를 설치해서 해보기 ) code blocks 등이 있음.
     Python 이나 R은 Linux에서 시작되었고 대부분의 핵심 코드가 C & C++이다.
     => Visual C++로 만들어서 Visual C++ 재배포 패키지를 설치해야 제대로 다운로드 받아서 실행이 됨.

     codeblocks 다운로드 codeblocks-20.03mingw-setup.exe	FossHUB or Sourceforge.net


     Java : Oracle에서 JDK를 받아서 다운로드 받거나 Open JDK를 받아서 설치 한 후 IDE를 설치.
     Java IDE : Eclipse, Intelli J ( 유료 - 무료 버전으로 웹 프로그래밍을 제외한 것은 전부 가능 )
     Intelli J 장점 : 코드 센스 기능이 우수하고 빌드 오류가 거의 없고 매개변수 네이밍을 추가. 코드를 알아보기 쉬움.
     Kotlin : Intelli J회사에서 꺼다. ( 따로 공부하기 )

     Java 팁 : path에 JDK의 bin 디렉토리를 설정해주는 것이 좋음. 
	    path라는 환경 변수는 명령어를 경로없이 실행할 수 있도록 해주는 환경변수. ( Python R도 동일 )


     Python : IDE가 다양하다. Anaconda를 설치하면 python compiler를 설치해주고,
                IDE( Spyder 나 jupyter notebook )도 제공하면 데이터 분석에 많이 사용되는 numpy, scipy 등도 설치해줌.
                Pycharm : Intelli J와 비슷한 환경. Pycharm을 사용할때는 python compiler를 꼭 설치해야됨.
                Python 설치 실수 : Python이나 Anaconda 설치할 때 path에 명령어가 있는 디렉토리를 추가할 것인지
                                        옵션이 나오는데 체크를 해주는게 작업을 할 때 편리합니다.
                                        pip install 명령이 실행이 안되면 path 설정이 안된 것입니다.
                                        pip install 했는데 코딩할 때 module이 없다고 나오는 경우는 파이썬이 2개 이상 설치된 것.


     최근에는 클라우드 환경에서 제공하는 IDE도 있다. 
     대표적인 것이 Google의 colab인데 여기서 python을 설치없이 실행해 볼 수 있다.
     최근의 코딩 테스트나 빅데이터 분석기사나 데이터분석 전문가 시험에서는 클라우드 환경의 IDE를 이용합니다.


3. Code Blocks 설치 후 해주어야 할 일.
 - [ Settings ] 메뉴에서 [ Compiler ]를 선택 한 후 ToolChain Excutables 탭에서 Auto Detect를 한 번 눌러주고 다시 실행.


4. Java 설치 후 Path 설정 - Windows에서만 합니다. ( Mac은 자동으로 설정해줌 )
 - Java가 설치된 디렉토리에서 jdk 디렉토리의 bin이라는 디렉토리의 경로를 복사.
 - 환경변수 창 위에는 현재 아이디에서만 사용, 아래창은 모든 OS 계정에서 사용.
 - 확인 방법 : cmd 창을 열고 java -version 을 쳤을때 JRE version이 나오면 환경변수 설정 완료.


5. 프로그램 언어의 실행.

 C언어는 빌드를 하게되면 운영체제가 이해할 수 있는 실행파일을 만들고 운영체제는 실행 파일을 실행.
 Python은 Python 번역기가 한 줄 단위로 읽으면서 번역하고 실행하기 때문에 실행파일이 필요없다.


6. Console 출력.
 
 C언어 : - printf 함수 이용. 
           - 서식은 반드시 %로 시작.
           - %d : 정수를 출력.
           - %f : 실수를 출력.
           - %c : 하나의 문자를 출력.
           - %s : 대응되는 참조부터 바이트 단위로 읽어서 문자로 출력하는데 null을 만날때까지 출력 - 참조 매핑 필수.
           - %자릿수영문자 형태 가능 : 자릿수는 데이터의 길이보다 크면 자릿수만큼 공간을 확보하고 데이터 출력.
                                               자릿수가 데이터의 길이보다 작으면 데이터를 전부 출력.
           - %전체자릿수.소수자리수f로 사용가능 : 전체 자릿수는 생략가능하고, 소수 자릿수에서 반올림한다.

          ex ) 1. printf("메시지");        2. printf( "메시지 와 서식 나열", 서식에 해당하는 데이터 나열 );

 Java : - System.out.print( ) : 모아서 한꺼번에 처리.
         - System.out.println( ) : 바로 바로 처리하고 줄 바꿈을 해줌.
         - System.out.printf( 서식 , 서식에 대한 데이터 ) : C언어와 같은 방식.


 Python : - print( 데이터 나열 ) :
            - print( '{순서:서식}'.format( 데이터 ) ) : C언어처럼 서식을 사용할때 

 제어문자 : \와 하나의 영문자를 조합해서 특수한 기능을 수행하는 문자.
              \n : 줄바꿈. 
              \t : 탭 만큼 띈다. 


7. 데이터와 자료형.


 # 데이터의 구분.

1 ) Literal : 개발자가 직접 입력한 데이터.
              
               C와 자바가 같은데 차이점은 한글 1글자를 문자로 인식하는지, 문자열로 인식하는지이다.
               C는 한글 1글자를 문자열로 판정, Java는 한글 1글자를 문자로 인식 가능합니다.
               Python은 문자와 문자열의 구분이 없고 모두 문자열로 표현합니다.

               수 표현.
               Python에서 정수는 모두 int이고 실수는 모두 float이다.
              
               boolean 표현.
               java ( boolean ) : true,false이다. ( 소문자 )
               Python ( bool ) : True, False이다. ( 대문자 )
               C언어 : boolean이 없다.

               문자 표현.
               문자 : '문자' -> 1글자.
               문자열 : "문자열" -> 0개 이상의 문자 집합.
               Python에서는 " ", ' ' 아무렇게나 사용 가능하다. 여러 줄의 경우는 ''' ''' , """ """으로 표현.
               가르키는 데이터가 없음 : java와 C는 null, python은 None.
               
	   배열.
               Java, C : { 데이터 나열 } 
               Python : 배열이 따로 없고 list라고 하는데 [ 데이터 나열 ] 으로 표현.

               튜플.
               Python에만 있는 데이터 표현 방식.
               튜플 : ( 데이터 나열.. ) 하는 것인데 데이터가 하나일때, ( 10 )은 튜플이 아니고 ( 10, )로 설정해야 튜플이다.

               set ( 중복없이 저장 ) : { 데이터 나열 } , { }는 dict.
                
               dict( Key와 Value를 쌍으로 저장 ) : { key:value, key:value...}


2 ) Constant : 변경할 수 없는 데이터.

	   C : const 자료형 이름 = 데이터;
               Java : final 자료형 이름 = 데이터;


3 ) Variable : 변경 가능한 데이터.
               
                C나 Java : 자료형 이름 = 데이터;
                Python : 이름 = 데이터


4 ) C와 java에서 배열 선언.

   C : 자료형 배열이름 [ ] 또는 자료형 * 배열이름 ( * 은 앞이나 뒤에 붙일 수 있음 : * 이 있으면 배열이다 )
   Java : 자료형 배열이름 [ ] 또는 자료형 [ ] 배열이름.


 # 자료형 
 
C언어 : Value Type과 Reference Type.  
          Value Type : char, unsigned char, shor, unsigend short, float, double, 배열.
          Reference Type : Pointer ( - * 이 붙음 )
          C 언어는 boolean이 없는데 0이면 false 0이 아닌 수는 true로 간주.

Java : 기본자료형 class로 나뉨.
        기본자료형 : byte, char, short, , int, long . float, double, boolean. ( 데이터 1개 저장하는 자료형 - null 사용 안됨 ) 
        그 이외 자료형은 배열과 클래스이다. ( 인터페이스, enum 포함 )

Python : scala type ( 1개 저장 )과 vector type ( 0개 이상 ).
           scala type : bool, int, float, complex ( 복소수 ).
           vector type : 그 외 자료형 모두. ( bytes, list, tuple, set, dict 등 )
           str은 문자의 list이다. ( 원래 자료형이 아니다 ) 


 # 배열의 데이터 접근.

C언어 : int ar[ ] = { 10, 30, 40 } ; 
          ar[ 0 ] : 10;
          ar[ 1 ] : 30;
          ar[ 2 ] : 40;
          ar[ -1 ] : 에러 아니고 무슨 값이 나올지 모름.
       
          ar : 참조가 리턴 - 값을 알지 못함.

          *( ar ) : ar에서 하나도 건너뛰지 말고 데이터를 가져오는 것. ( 10 )
          *( ar + 1 ) : ar에서 하나를 건너뛰고 데이터를 가져오는 것. ( 30 )
          *( ar + 2 ) : ar에서 두개를 건너뛰고 데이터를 가져오는 것. ( 40 )

          
          int ar[ ][ ] = { { 10,30,40 }, { 130,120,190 } } ;

           ar[0][0] : 10;
           ar[0][1] : 30;
           ar[1][0] : 130;
  
           ar -> ar[0] -> ar[0][0] : 10
                             ar[0][1] : 30
                             ar[0][2] : 40
                  ar[1] -> ar[0][0] : 130
                             ar[0][1] : 120
                             ar[0][2] : 190

           **ar : 10  ( *이 2개 들어가야 값을 알 수 있다 )


Java : C언어와 거의 똑같다.
	
        int ar[ ][ ] = { { 10,30,40 }, { 130,120,190 } } ;
        
        ar[ -1 ] : ArrayIndexOIutOfBounceException이다.
        ar.length :  2개 
        ar[0].length : 3개
        ar[0][0].length : error.


Python : 배열이 없어서 List로 공부한다.

           ar = [ 10,30,50,70,90 ]
           
           ar[1] : 10.
           ar[ 시작위치 : 종료다음위치 ] : 슬라이싱.
           ar[ 음수 ] : 맨 뒤에서 시작.

           ar[ -1 ] : 90
           ar[ -2 ] : 70
           
           ar[ 1:4 ] : [ 30,50,70 ] 1번부터 3번까지 
           ar[ : 4 ] : [ 10,30,50,70 ] 시작위치 생략하면 처음부터.
           ar[ 1: ] : [ 30,50,70,90 ] 종료위치 생략하면 끝까지.

           슬라이싱 사용시 List로 반환한다.


 # 인덱스의 시작 번호.

컴퓨터를 위한 프로그램은 0 부터 시작 - C, Java, Python, Javascript 등.
                                                  Python [ 0:3 ] : 0부터 2까지.
                                              

인간을 위한 프로그램은 1부터 시작 마지막도 포함 - excel, database 등.
                                                                R [ 'A', 'C' ] : A부터 C까지.



 # 연산자 

Java : boolean만 인정. ( true와 false만 가능 )
C : 0이면 false, 나머지 숫자는 true.
Python : bool이 있고, 0이면 false, 그 이외에 숫자는 true, 
           데이터를 가지지 않은 vector는 False, 데이터를 가진 vector는 True.


 최우선 연산자

함수, ( ), [ ], . ( vector 들이 자신의 속성이나 메소드를 호출하기 위한 기호 ), 
-> ( C언어에서 참조형 vector가 자신의 값을 찾아갈 때 사용 )


 단항 연산자.

C언어만 가능
* : 참조형에서 자신의 데이터를 찾아가기 위한 기호.
& : 변수나 상수에서 자신을 참조하기 위한 참조값.
sizeof : 메모리 크기 측정.

Python만 없음.
++, -- : 변수의 값을 1증가시키거나 감소 시킵니다. 위치에 따라 값이 달라짐.
( 자료형 ) : 실수는 정수로 변환되면 소수는 버려진다.

전부 다 있음.
+, - : 양수, 음수.
~ : 1의 보수.

보수 
a = - 11;
a = 11       11의 2의보수를 구한다 : 1의 보수 + 1

첫번째 비트가 1이면 음수, 첫번째 비트가 0이면 양수.


 산술 연산자.

C언어 : 숫자만 사용가능합니다.

% : 정수 데이터에서만 사용 가능하고, 나머지를 구해줍니다.
      ex ) 10%3 = 1

* : C언어, 자바 - 숫자 사이에서만 곱하기 가능.
    Python - list도 정수와 *가 가능.
               ex ) [ 10 ] * 3 = [ 10,10,10 ]

/ : C언어, 자바 - 정수/정수하면 몫만 나옴.
    Python - 정수/정수하면 실수 가능.
                                         

+ : C언어 - 숫자만 더하기가 가능.
     Java - 문자열끼리 가능, 문자열과 다른 객체도 더하기가 가능 ( 객체의 toString( )를 호출한 결과와 결합 )
     Python - 자료형이 같은 경우만 + 가 가능. ( 문자열과 숫자 안됨 )
                 vector 자료형도 더하기가 가능.
                 ex ) [ 100, 200 ] + [ 300, 400 ] = [ 100,200,300,400 ]

- : 숫자끼리만 가능.


 shift 연산자.

정수 데이터만으로 가능하다.

데이터 << 횟수.      2**횟수만큼 곱한 결과.
데이터 >> 횟수.      2**횟수만큼 나눈 결과.

Java의 경우 횟수가 32번 이상이면 32번 나눈 나머지 만큼만 수행합니다.

ex ) 2 << 4 : 32
     2 << 36 : Java에서는 32, Python에서는 2**36만큼 곱한다.


 관계 연산자.

<, <=, >, >=

숫자 데이터를 가지고 연산하고 결과를 true, false로 리턴.

Java : true, false.   Python : True, False.     C언어 : 1( true ), 0 ( false )


 등가 연산자.

==, !=

C언어 : Value 형은 값을 비교하고, Reference형은 참조를 비교.
Java : 기본형은 값을 비교하고, Reference형은 참조를 비교.
Python : Scala Type은 값을 비교.


 비트 논리 연산자.

C언어, Java에서는 정수에서만 사용할 수 있는 연산자로 2진수로 변경해서 연산을 하고 10진수로 리턴합니다.

& ( 비트 AND ) : 둘다 1일때만 1
| ( 비트 OR ) : 둘 중 하나이상 1일때 1이다.
^ ( XOR ) : 같으면 0, 다르면 1이다.

AND 

0 0 -> 0
0 1 -> 0
1 0 -> 0
1 1 -> 0 

or 

0 0 -> 0
0 1 -> 1
1 0 -> 1
1 1 -> 1

XOR

0 0 -> 0
0 1 -> 1
1 0 -> 1
1 1 -> 1

Python : list에도 비트연산자를 사용할 수 있다.
           요소 각각에 연산을 수행해서 list로 리턴한다.


 조건 논리 연산자.

&& : 둘 다 true일 때만 true 반환.
|| : 둘 다 false일 때만 false 반환.

and, or : Python 

비트 논리 연산은 앞의 내용이 어떤 결과를 만들더라도 뒤의 내용을 수행합니다.
조건 논리 연산은 뒤에 내용이 결과값에 영향이 없다면 앞에 내용만 수행한다. ( Don't care라고 말하기도 함 )

Python은 list와 같은 집합에서도 조건 논리 연산자를 사용할 수 있다.

[ 10, 30, 0 ] or [ ] = [ 10, 30, 0 ]    ( 합집합 )
[ 10, 30, 0 ] or [ ] = [ ]                ( 교집합 ) 

Python 데이터 분석 라이브러리 : 비트 논리 연산자는 각 요소마다 연산을 해서 결과의 집합으로 리턴하고
                                         조건 논리 연산자는 전체를 하나로 보고 연산을 수행합니다.
                                         ( 비트 논리 연산자를 더 많이 사용한다 )


 삼항 연산자.

boolean ? A : B ; 

boolean의 값이 true이면 A를 반환하고, false이면 B를 반환한다.


 할당 연산자 ( 대입 연산자 )

= : 오른쪽의 데이터를 왼쪽의 변수가 가리키는 공간에 대입.

연산자 = : 오른쪽의 데이터에 왼쪽의 데이터와 연산을 해서 대입.
             ex ) x = 10;  x += 10;     x = 20;


 
 # 제어문.

 if 조건문.

if( 조건 ) { true일 때 수행할 내용; }
else if ( 조건2 ) { 조건1이 false이고, 조건2가 true일 때 수행할 내용; }
else { 위에 조건들이 모두 false 일때 실행할 내용; }

if는 필수이고, else if는 0번 이상 무제한, else는 0~1번만 등장.

python : 조건에 괄호를 하지 않아도 되고 { 대신에 : 이고 블럭 안의 내용은 동일한 간격의 들여쓰기가 적용되어야 함.
           else if 대신에 elif를 사용한다.
           블럭의 기호 - : 과 들여쓰기.

C, Java : 블럭의 기호 - { }.


 switch문.

Python : 최근의 버전에서 추가되었다. ( 문제가 안나올 가능성이 크다 )

Switch( 정수가 나오는식 - 자바는 문자열도 가능 ) {

       case 값1 :
                   식의 결과가 값1일때 실행할 문장;
                   break;   ( 써도 되고 안써도 된다 )
       case 값2 : 
                   식의 결과가 값2일때 실행할 문장;
                   break;   ( 써도 되고 안써도 된다 )
       default : 
                   식의 결과가 앞에 값들에 존재하지 않을 경우 실행할 문장. ( break가 없어도 사용 )
}

break가 없으면 다음 case의 값도 같이 출력한다. 

ex ) case 값1에 break가 없으면 식 = 값1이면 값1의 문장과 값2의 문장을 모두 반환한다.


 While문.

C, Java : while( boolean ) { 수행할 내용; }
Python : while boolean : 수행할 내용

boolean가 true이면 { }안의 내용을 계속 수행. false가 되면 종료.

피보나치 수열 : ( n-1 ) + ( n-2 ) = n 


 do ~ while문.

Python : 없다.
C, Java : do { 반복할 내용 } while ( boolean );

무조건 1번은 반복해야 될 경우 사용한다. boolean이 false가 되면 do에 반복문이 종료된다.


 for문. ( 약간 어려움 )

C, Java의 일반적인 for문 : for ( 처음할 내용; 중단조건; 두번째부터 수행할 내용 ) { 반복할 내용; }
                                 for ( ) 안에서 2개 이상의 문장을 작성하고자 하면 ' , ' 로 구분.
                                 for ( ) 의 모든 식은 생략이 가능.
                                 중단 조건을 생략하면 무한 반복. 
                                 ex ) for ( int i; i<=10; i++) { System.out.println(i); }

Java에서만 쓸 수 있는 방식 : for ( 임시변수 : collection ){ collection의 모든 내용을 임시변수에 대입하고 실행할 문장; } 

Python에서만 쓸수 있는 방식 : for 임시변수 in collection : collection의 모든 내용을 임시변수에 대입하고 실행할 문장
                                      range([시작값, ] 종료다음값[, 간격] ) - 시작값부터 종료값까지 간격으로 생성.
                                      range (0,10,1) : 0,1,2,3...9 - 시작값 생략 = 0, 간격 생략 = 1.


 break와 continue.

break는 switch나 반복문을 중단하는 제어 명령어.
ex ) if ( i % 3 == 0 ) { break; }          i가 3의배수이면 중단한다.

continue는 다음으로 넘어갑니다. ( 특별한 경우가 아니면 if와 함께 사용 - 무조건 넘어가는 경우는 거의 없다 )
ex ) if ( i % 3 == 0 ){ continue; }       i가 3의 배수이면 건너띈다.


 제어문 안에 제어문 사용된 경우.

반복문 안에 반복문 사용될 때 확인을 잘 해야 된다. ( 헷갈린다 )
ex ) 별찍기 생각해보기.


 집단 자료형. ( 시험에 나올만한 것들 )

C언어 : 배열과 포인터 이용을 공부해라.
          ex ) * ( ar ) = ar[ 0 ] ,  *( ar + 1 ) = ar[ 1 ]
          %s는 대응되는 참조부터 null을 만날때까지. byte 단위로 읽어서 문자로 출력.
          ex ) char str[ 5 ] = "Hello" ;    "Helloㅁ" 끝에 이상한 문자가 하나가 같이 출력.
                printf( "%s%n", str + 2 );   "llo" 2칸 이동해서 출력.

Java : 배열에 특별하게 헷갈리는 부분이 없다.

Python : 배열에 슬라이싱이 가능하다.
            ex ) s = "Hello Python"
                 print( s[0:3] )             Hel 출력. ( 슬라이싱 )
                 print( s[-1] )              n 출력. ( 음수는 뒤에서부터 출력 ) 

            set 방식 중복이 안된다. ( Java에서도 마찬가지 )
             ex ) hashset = { 10, 20, 30 }
                   hashset.update( [10, 50] )
                   print(hashset)                 10, 20, 30, 50 출력.  10은 중복되어 하나만 표시된다.


 함수 

C언어와 Python에만 존재한다.

C : 기본 데이터 앞에 &이 붙으면 참조를 전달.
    배열 이름만 사용해도 참조를 전달한 것입니다.
   
    참조를 전달하면 함수 내부에서 매개변수로 대입된 데이터를 변경할 수 있습니다. ( call by reference 라고 한다 )
    참조가 아니라 데이터를 전달하면 매개변수로 대입된 데이터를 변경해도 원본에 영향을 미치지 않습니다. 
    ( call by value 라고 한다 )

    call by value
    ex ) void callbyvalue( int x ) { x = x + 1; printf( "x=%d\n" , x }
         int main ( ) { int i = 1; callbyvalue( i ); printf( "i=%d\n", i ); }  

    call by reference
    ex ) void callbyreference( int *p ) { p[0] = p[0] + 1; printf( "%d\n", p[0] ); }
          int main ( ) { int i = 1; int ar [ ] = { 10, 20 } ; callbyreference( ar ) ; printf ( "ar[0]:%d%n", ar[0] ); } 
          or
          int main ( ) { int i = 1; callbyreference ( &i ); prinft( "i:%d\n", i ) 


Python : 1개만 저장할 수 있는 자료형인지, 여러개 저장하는 자료형인지 확인.
           1개는 call by value이고 여러개는 call by reference 이다.
           Python은 여러개 저장할 때 [ ] , ( ), { } 를 사용한다.
           문자열은 해당되지 않음.


 클래스와 인스턴스.

Java에만 해당.

Java : 인스턴스를 만들때는 new 생성자( )를 이용합니다. 
        객체 상속 : extends를 이용.
        인터페이스 상속 : impliment를 이용.
        오버라이딩 : 상위 클래스의 메소드를 하위 클래스에서 재조작 ( 구현 )
        추상메소드 : 모양만 가지고 있는 메소드로 하위클래스에서 반드시 overring해야 사용할 수 있다.
        접근지정자 : private : 자신의 클래스 내부에서만 사용이 가능.
                        default ( package ) : 동일한 패키지 내에서 있으면 사용가능.
                        protected : 동일한 패키지 내에서 사용가능, 다른 클래스의 상속받은 클래스에서 사용가능.
                        public : 클래스 내부에서 사용이 가능하고 외부( 인스턴스 )에서도 사용 가능.
        다형성 : 부모 타입의 참조변수에 자식객체의 메소드를 불러올때, 오버라이딩 된 내용이 불러와진다. 
        
        
 예외처리.

try { 예외 발생 가능성이 있는 코드 }
catch ( 예외 클래스 변수명 ) { 예외 발생했을 때 수행할 내용 }
finally { 예외 발생 여부에 상관없이 수행할 내용 }



 # 애플리케이션 테스트.

애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차.
애플리케이션 테스트 : Verification - 기능을 정확하게 수행하는지 확인하는 것.
                            Validation - 고객의 요구 사항을 만족하는지 확인하는 것.


 테스트의 기본원리.

1. 완벽한 테스트는 불가능.

2. 결함 집중 : 개발자의 특성이나 애플리케이션의 기능적 특성 때문에 결함이 발생할 가능성이 높기 때문에,
                 특정 모듈에 집중될 가능성이 높음.
                 결함의 80%는 20%에 해당하는 코드에서 발생 - 팔레토 법칙. 

3. 살충제 패러톡스 : 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않을 수 있다.
                         ( 항상 새로운 테스트로 해야 된다 )

4. 테스트는 정황에 의존 : 정황( 상황 )에 따라 다르게 테스트해야 된다.

5. 오류 - 부재의 궤변 : 모든 오류를 제거했더라도 사용자의 요구사항을 만족시키지 못했다면 좋은 애플리케이션이 아니다.

6. 테스트와 위험은 반비례한다

7. 테스트의 점진적 확대 : 점차 늘려가면서 진행한다.

8. 테스트는 개발팀이 아닌 별도의 팀이 수행하는 것이 좋다 : 다른 시각에서 볼 수 있다 ?


 테스트의 분류 

1. 프로그램 실행 여부에 따른 분류.
 
 - 정적 테스트 : 프로그램을 실행하지 않고 테스트하는 방법으로 코드 검사, walk through( 정형 검토 회의 - 오류 발견 ) , 
   inspection( 심사 - 오류 발견 후 수정 )이 있음. 

 - 동적 테스트 : 프로그램을 실행해서 테스트하는 방식 black box text, white box test.


2. 시각에 따른 분류.

 - 검증 ( verification ) : 개발자의 시각에서 테스트, 내가 설계한 대로 잘 만들어졌는지 확인.

 - 확인 ( validation ) : 사용자의 시각에서 테스트, 사용자의 요구 사항대로 만들어졌는지 확인.


3. 테스트 기반에 따른 분류.

 - 명세 기반 테스트 : 명세서를 가지고 테스트. ( 테스트 목록을 보면서 테스트 ) 

 - 구조 기반 테스트 : 애플리케이션 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 것.

 - 경험 기반 테스트 : 과거의 경험을 가지고 테스트.


4. White Box 와 Black Box Test.

 - White Box Test : 코드를 오픈한 상태에서 코드의 논리적인 모든 경로를 테스트하는 것.
                        문장 단위로 검증, 분기 검증 ( if, switch ),  조건 검증, 분기/조건 검증 등.
                        종류는 기초 경로 검사, 제어 구조 검사 등이 있음.

 - Black Box Text : 기능이 완전히 작동되는 것을 검증.
                       동등값 분할 ( equivalence partitioning ) : 입력 자료에 초점을 맞춰서 테스트 케이스를 생성.
                                                                          ( 정상적인 값과 그렇지 않은 값을 대입해서 테스트 )
                       경계값 분석 ( Boundary Value Analysis ) : 경계값 위주로 테스트. 
                       원인 효과 그래프 ( Cause Effect Graph ) : 입력 데이터와 출력 데이터의 관계를 확인.
                       오류 예측 ( Error Guessing ) : 오류를 예측해서 검사.
                       비교 검사 ( Comparison Test ) : 여러 버전의 프로그램에 동일한 테스트 자료를 제공해서 결과 확인.


5. 개발 단계에 따른 테스트.

 - Unit Test ( 단위 테스트 ) : 함수나 클래스 단위로 테스트.
 
 - Integration Test ( 통합 테스트 ) : 단위 테스트가 끝난 모듈을 모아서 테스트.

 - System Test : 애플리케이션이 컴퓨터 시스템에서 제대로 동작하는지 테스트.

 - Acceptance Test : 사용자의 환경 또는 운영환경에서 제대로 동작하는지 테스트.
                          알파테스트 : 개발자의 장소에서 사용자가 테스트.
                          베타테스트 : 사용자의 장소에서 사용자가 테스트.


6. Test Oracle.

 - Test 결과가 올바른지 판단하기 위해서 사전에 정의된 참값을 대입하여 비교하는 기법이다.

 1 ) True Oracle : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클로 발생된 모든 오류를 검출.

 2 ) Sampling Oracle : 특정한 몇몇 테스트 케이스의 입력 값에 대해서만 기대하는 결과를 제공하는 오라클.

 3 ) Heuristic Oracle ( 추정 오라클 ) : 샘플링 오라클을 보완하는 방법으로, 
                                              특정 케이스의 입력값에 대해 기대하는 결과를 제공하고 나머지는 추정하는 방식.

 4 ) Consistent Oracle : 애플리케이션이 변경된 경우 변경 전과 후의 결과가 같은지 확인하는 오라클.


7. Test Harness Tool

 - 테스트가 실행 될 환경을 시뮬레이션 해서 컴포넌트 및 모듈이 정상적으로 테스트 되도록 해주는 도구.

 1 ) Test Driver : 하위 모듈을 호출하기 위한 도구.

 2 ) Test Stub : 상위 모듈을 호출하기 위한 도구.
 
 3 ) Test Suites : 테스트 대상 컴포넌트나 모듈 및 시스템에 사용되는 모든 테스트 케이스의 집합.

 4 ) Test Case : 테스트 항목의 명세서. 

 5 ) Test Script : 자동화된 테스트 실행 절차에 대한 명세서.

 6 ) Mock Object : 사용자의 행위를 조건부로 입력해 두면 그 상황에 맞는 예정된 행위를 수행하는 객체.


8. 애플리케이션 성능 지표.

 - 처리량 ( Throughput ) : 일정 시간 내에 애플리케이션이 처리하는 일의 양.

 - 응답시간 ( Response Time ) : 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간.

 - 경과시간 ( Turn Around Time ) : 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간.

 - 자원사용률 ( Resource Usage ) : 처리하는 동안 사용한 자원의 양.


9. 알고리즘 분석 - 복잡도.

 - 시간 복잡도 
 
 - 공간 복잡도

 - Macabe의 순환 복잡도 : 논리적인 복잡도를 측정하기 위한 방법.
                                 복잡도 = 노드의 수 ( 원 - 작업 ) - 간선의 수 + 2


10. 소스 코드 최적화.

 1 ) Bad Code : 안 좋은 코드.

 2 ) Clean Code : 누구나 이해하기 쉽고, 수정 및 추가를 쉽게 할 수 있는 코드.

 3 ) 스파게티 코드 : 동일한 코드가 중복되어서 복잡하고 이해하기 어려운 코드.

 4 ) 외계인 코드 : 너무 오래되서 설계 관련 정보가 없는 코드로 역공학( reverse Engineering )을 이용해서 
                      설계정보를 추출해야 한다.

 5 ) 역공학 : 코드에서 설계 정보를 만들어 내는 것.

 6 ) 클린 코드 작성 원칙 : 가독성, 단순성, 의존성 배제, 중복 최소화, 추상화.

 7 ) 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고 결합도를 작게 해야 합니다.

 8 ) Loosely Coupled ( 느슨한 결합 ) : 클래스 간의 의존성을 줄이는 것.


11. Debugging.

Debugging : 논리적인 결함이나 예외를 제거하기 위해서 메모리를 확인하는 작업.



 # 소프트 웨어 패키징.

소프트웨어 패키징 : 모듈 별로 생성한 실행 파일들을 묶어서 배포용 설치 파일을 만드는 것.


1. 형상 관리.

 - 소프트웨어 개발 과정에서 발생한 변경 사항을 관리하는 것.


2. 형상 관리도구.

 - git 

 - svn 


3. 형상 관리 용어 및 명령어.

 - commit : 변경 사항을 업데이트 하는 것.

 - branch : 변경 사항을 관리하기 위해서 저장하는 저장점.


4. build. 

 - compiler된 코드들을 묶어서 실행 파일로 만드는 과정.

 - java build tool : maven, gradle, jenkins. ( 강사님 추천 jenkins )


5. 이행 ( Migration ) 

 - 개발 환경에서 운영 환경으로 이전하는 동작.



다음주 : 요구사항 확인, database, 응용기초개발, 그리고 나머지.












