
 자료구조와 알고리즘.



 # 자료구조.

선형구조.
자료를 구성하는 데이터를 순차적으로 1:1로 나열시킨 자료구조.
List : DenseList, ArrayList, LinkedList( 연결 리스트 ).
Stack
Queue.
Deque( Doubly Ended Queue ) : Stack과 Queue의 결합으로 Scroll 입력 한쪽 제한, Shelf 출력 한쪽 제한.

비선형 구조.
데이터의 불연속적인 모임.
Tree, Graph.



 # List.

List.
동인한 자료형의 데이터를 순서대로 저장하는 자료구조.
순선대로 = 차례대로 = 한 줄로 = 선형 구조로.
다른 자료구조를 구현하는 수단으로도 사용.

순차 자료 구조.
시작부터 끝까지 빈자리 없이 자료를 순서대로 연속하여 저장.
중간에 데이터 변경시 그 이후 데이터가 빈자리로 이동하면서 채워진다.

연결 자료 구조.
메모리에 저장된 물리적 위치나 물리적 순서와 상관없이 연결에 의해 순서를 표현하는 방식.
중간에 데이터 변경시 링크 정보만 변경되고 물리적 순서는 변경되지 않는다.



 # Array.

배열.
크기가 고정 - 한 번 생성되면 크기를 변경할 수 없음.
빈 공간없이 데이터를 저장하기 때문에 메모리 효율이 좋음.
데이터를 중간에 삽입하거나 삭제할 수 없음.



 # ArrayList & LinkedList.

ArrayList.
배열과 유사한 형태로 동작하지만 삽입과 삭제를 고려해서 여분의 공간을 확보하고 있다. ( Vector )

LinkedList.
Data와 Link로 구성된 노드들로 구성된 List.
Data : 실제 자료를 저장. 
Link :  다음 데이터의 위치를 저장하는 구조를 가진다.
연속된 공간에 저장될 필요가 없는 자료구조이다. 

LinkedList 원리.
데이터의 삽입 : 새로운 노드를 만들어서 Link만 수정.
데이터의 삭제 : 삭제할 데이터의 앞 노드를 찾아서 Link를 수정.

배열에 비교해서 가지는 장점.
데이터의 변경이 있을 때 이동 연산이 불필요하기 때문에 훨씬 유리하다.
불연속적으로 데이터를 저장하기 때문에 개수를 정하지 않아도 사용할 수 있다.

배열과 비교해서 가지는 단점.
구현의 어려움 : 동적인 메모리 할당을 해야하기 때문에 구현의 비용이 높음.
메모리 누수 발생 가능성이 높음.
데이터를 탐색하는 비용이 높음.

종류.
Single Linked List : 하나의 Link만은 가지고 다음 데이터를 가리키는 형태.
Circular Linked List : 마지막 노드의 Link에 첫번쨰 데이터의 위치를 저장시키는 형태.
Double Linked List : 2개의 Link를 가지고 다음 데이터와 이전 데이터의 위치를 저장시키는 형태.



 # Stack.

stack.
자료를 차곡차곡 쌓아 올린 형태의 자료구조. ( FILO )
한 방향에서 데이터를 삽입( push ) / 삭제( pop ) 할 수 있다.

원소 삽입 / 삭제 과정.
데이터가 없는 상태에서 pop을 하면 UnderFlow 발생.
데이터가 전부 저장된 상태에서 데이터를 push하면 OverFlow라는 예외가 발생.

Stack 용도.
운영체제( Operating System ) : 프로그램에서 사용되는 함수들을 스택 자료형에 저장하여 사용.
컴파일러( Compiler ) : 수학 기호들을 기계어로 변환 시 사용.
자바 가상 머신( JVM ) : JVM 내에서 메소드가 실행, 종료될 때 스택 프레임을 이용하여 관리.



 # Queue

Queue.
삽입과 삭제를 서로 다른 방향에서 하는 구조. ( FIFO )



 # 트리 Tree.

트리.
계층 구조로 자료를 저장하는 구조.
노드 : 실제 값이 저장되는 장소.
간선 : 노드들 사이의 부모 - 자식 관계를 정의.
회사의 조직도, 컴퓨터의 디렉토리 구조 등이 대표적이며 머신러닝에 사용되는 의사결정 트리 등이 있다.

노드의 종류.
Root : 트리의 첫번째 노드.
Leaf( Terminal ) : 자식 노드가 없는 노드.
Internal : 자식 노드가 있는 노드.

노드 사이의 관계.
Parent : 간선으로 연결된 상위 노드.
Child : 간선으로 연결된 하위 노드.
Ancestor( 선조 ) : root에서 Parent까지의 경로 상에 있는 모든 노드.
Descendant( 후손 ) : 특정 노드의 아래에 있는 모든 노드.
Sibiling( 형제 ) : 같은 부모 노드의 자식 노드.

노드의 속성.
Level : 루트 노드부터의 거리.
Height : 루트 노드로부터 가장 먼 거리에 있는 자식 노드의 높이에 1을 더한 값.
Degree : 한 노드가 가지는 자식 노드의 개수.
Subtree : 트리에 속한 노드들의 부분 집합.
Forest : 특정 노드가 제거되면서 만들어지는 Subtree의 집합.

Binary Tree.
모든 노드의 차수가 2 이하인 트리.

Binary Tree의 종류.
포화 이진 트리( Full Binary Tree ) : 모든 레벨의 노드가 꽉 차 있는 이진 트리.
완전 이진 트리( Complete Binary Tree ) : 높이가 h이고 노드 수가 n개일 때.
편향 이진 트리( Skewed Binary Tree ) : 왼쪽 또는 오른쪽 서브트리만 가진 이즌 트리.

Binary Tree 순회.
전위 순회( Preorder Traversal ) : 현재 노드를 처리, 왼쪽 서브트리 처리, 오른쪽 서브트리 처리. ( 위 -> 왼 )
중위 순회( Inorder Traversal ) : 왼쪽 서브트리 처리, 현재 노드처리, 오른쪽 서브트리 처리. ( 아래 -> 중간 )
후위 순회( Postorder Traversal ) : 왼쪽 서브 트리 처리, 오른쪽 서브트리 처리, 현재 노드 처리. ( 아래부터 )

Heap.
완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드, 가장 작은 노드를 찾기 위해 만든 자료구조.
max heap : 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리.
min heap : 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리.

Heap의 삽입 연산.
트리의 마지막 자리에 임시 저장.
부모 노드와 키 값 비교 및 이동.

Heap의 삭제 연산.
반드시 루트 노드만 삭제.
트리의 마지막 노드를 루트로 이동.



 # 수식 표기법.

Infix.
일반적인 수식의 표기법.
두 개의 피연산자 사이에 연산자가 존재하는 형태.

Postfix.
연산자를 피연자의 뒤쪽에 표시하는 방법.
Stack을 사용한 컴퓨터의 계산을 위해서 고안된 방법이다.
연산자를 뒤로 보낸다.

Prefix.
연산자를 앞으로 배치하는 방법이다.
괄호의 앞으로 연산자를 보내면 됨.



 # Graph.

Graph.
연결되어 있는 원소 사이의 다:다 관계를 표현하는 자료구조.
표현능력이 우수하여 현실 세계의 다양한 문제를 효과적으로 모델링하기 위한 자료구조.
객체를 나타내는 정점( vertex )와 객체를 연결하는 간선( edge )의 집합.

용어.
정점( vertex ) : 위치라는 개념. ( node라고도 부름 )
간선( edge ) : 위치 간의 관계. 즉 노드를 연결하는 선. ( Link, branch 라고도 부름 )
인접 정점( adjacent vertex ) : 간선에 의해 직접 연결된 정점.
정점의 차수( degree ) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수.
진입 차수( in-degree ) : 방향 그래프에서 외부에서 오는 간선의 수. ( 내차수 )
진출 차수( out-degree ) : 방향 그래프에서 외부로 향하는 간선의 수. ( 외차수 )
경로 길이( path length ) : 경로를 구성하는 데 사용된 간선의 수.
단순 경로( simple path ) : 경로 중에서 반복되는 정점이 없는 경우.
사이클( cycle ) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우.
인접( Adjacent ) : 두 개의 노드를 연결하는 간선이 존재하는 경우.
Incident( 부속 ) : 간선 ( Vi, Vj )는 정점 Vi와 Vj에 부속되어 있다고 함.
Loop : 그래프의 임의의 노드에서 자기 자신으로 이어지는 간선.

Graph의 종류.
무방향 그래프 : 간선에 방향이 없는 그래프.
방향 그래프 : 간선에 방향이 있는 그래프.
가중 그래프 : 간선에 가중치가 할당된 그래프.
완전 그래프 : 연결 가능한 최대 간선 수를 가진 그래프.
부분 그래프 : 원래의 그래프에서 일부의 노드나 간선을 제외하여 만든 그래프.
다중 그래프 : 중복된 간선을 포함하는 그래프.

Graph의 구현.
인접 행렬 : 그래프의 두 정점을 연결한 간선의 유무를 행렬로 저장. ( 순차 자료 구조 )
인접 리스트 : 배열의 크기 = 정점의 수. ( 연결 리스트 이용 )

Graph 탐색.
깊이 우선 탐색( DFS - Depth First Search ) : 가장 끝까지 갔다가 마지막 갈림길로 돌아와서 끝까지 간다.
너비 우선 탐색( BFS - Breadth First Search ) : 방문하지 않은 정점을 차례로 방문하는 방식. ( 순서대로 )



 # 정렬.

정렬.
데이터를 순서대로 나열하는 것.
오름차순, 내림차순이 대표적이고 정렬을 구현하는 방법은 알고리즘에 따라 여러가지이다.

내부정렬( Internal sort )
정렬할 자료를 메인 메모리에 올려서 정렬하는 방식.
정렬 속도가 빠르지만 정렬할 수 있는 자료의 양이 메인 메모리의 요량에 따라 제한됨.

외부정렬( External sort ) 
정렬할 자료를 보조 기억장치에서 정렬하는 방식.
내부 정렬보다 속도는 떨어지지만 대용량의 자료에 대한 정렬 가능.

선택정렬( Selection sort )
모든 데이터들과 비교해서 기준 자리의 데이터를 정리한다.

버블정렬( Bubble sort )
n 개의 데이터가 있을 때 1부터 n-1 번째 자료까지 n-1번 동안 다음 자료와 비교.

삽입정렬( Insertion sort )
정렬되어 있는 부분집합에 정렬할  새로운 원소의 위치를 찾아 삽입하는 방법.

Quick Sort.
가운데 원소를 피봇으로 삼고 피봇보다 크거나 같은 원소를 L, 작은 원소를 R로 표시.
R은 L과 만나면 더 이상 왼쪽으로 이동하지 못한다.

Shell Sort.
일정한 간격으로 떨어져있는 자료들끼리 부분집합을 구성하고 삽입 정렬을 반복 수행.

Merge sort - 2 WAY 방식.
분할( Divide ) : 자료들을 두 개의 부분집합으로 분할한다.
정복( Conquer ) : 부분집합에 있는 원소를 정렬한다.
결합( Combine ) : 정렬된 부분집합들을 하나의 집합으로 정렬하여 결합한다.

Radix sort.
원소의 키값을 나타내는 기수를 이용한 정렬 방법.

Heap sort.
최대, 최소 히프에 대해서 원소의 개수만큼 삭제 연산을 수행하여 정렬 수행.



 # Search.

순차검색.
데이터가 정렬되어 있지 않은 경우 첫 번째 데이터부터 마지막 데이터까지 모두 확인.
여러번 검색해야 하는 경우, 데이터가 많은 경우 비효율적인 방법.

이분검색.
데이터가 정렬되어 있는 경우 중앙 값과 비교해서 작으면 왼쪽으로 크면 오른쪽으로 이동해서 검색.

해시 알고리즘.
해시 함수를 이용해서 자료를 저장하거나 검색하는 자료구조 및 알고리즘.
해싱( Hashing ) : 해시 함수에 의래 자료를 저장할 위치나 자정한 위치를 계산하는 것.
검색 속도가 가장 빠름.


















